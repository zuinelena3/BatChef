% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/seuratV5Run.R
\name{seuratV5Run}
\alias{seuratV5Run}
\title{Seurat V5 method}
\usage{
seuratV5Run(
  input,
  method = "CCAIntegration",
  orig.reduction = "pca",
  assay = NULL,
  features = NULL,
  layers = NULL,
  scale.layer = "scale.data",
  new.reduction = "integrated.dr",
  reference = NULL,
  normalization.method = "LogNormalize",
  dims = 1:30,
  k.filter = NA,
  dims.to.integrate = NULL,
  k.weight = 100,
  weight.reduction = NULL,
  sd.weight = 1,
  sample.tree = NULL,
  preserve.order = FALSE,
  verbose = TRUE,
  l2.norm = TRUE,
  k.anchor = 5,
  k.score = 30,
  max.features = 200,
  nn.method = "annoy",
  n.trees = 50,
  eps = 0
)
}
\arguments{
\item{input}{A \linkS4class{Seurat} object.}

\item{method}{Integration method function.}

\item{orig.reduction}{Name of dimensional reduction for correction.}

\item{assay}{Name of assay for integration.}

\item{features}{A vector of features to use for integration.}

\item{layers}{Names of normalized layers in assay.}

\item{scale.layer}{Name(s) of scaled layer(s) in assay.}

\item{new.reduction}{Name of new integrated dimensional reduction.}

\item{reference}{A reference Seurat object.}

\item{normalization.method}{Name of normalization method used:
LogNormalize or SCT.}

\item{dims}{Number of dimensions of dimensional reduction.}

\item{k.filter}{Number of anchors to filter.}

\item{dims.to.integrate}{Number of dimensions to return integrated values for.}

\item{k.weight}{Number of neighbors to consider when weighting anchors.}

\item{weight.reduction}{Dimension reduction to use when calculating
anchor weights.}

\item{sd.weight}{Controls the bandwidth of the Gaussian kernel for weighting.}

\item{sample.tree}{Specify the order of integration.}

\item{preserve.order}{Do not reorder objects based on size for each
pairwise integration.}

\item{verbose}{Print progress bars and output.}

\item{l2.norm}{Perform L2 normalization on the CCA cell embeddings after
dimensional reduction.}

\item{k.anchor}{Number of neighbors (k) to use when picking anchors.}

\item{k.score}{Number of neighbors (k) to use when scoring anchors.}

\item{max.features}{The maximum number of features to use when specifying
the neighborhood search space in the anchor filtering.}

\item{nn.method}{Method for nearest neighbor finding.}

\item{n.trees}{More trees gives higher precision when using annoy approximate
nearest neighbor search.}

\item{eps}{Error bound on the neighbor finding algorithm.}
}
\value{
A \linkS4class{Seurat} object.
}
\description{
SeuratV5 is an anchor-based method.
}
\examples{
sim <- simulated_data(nGenes = 1000, batchCells = c(150, 200),
                      group.prob = c(0.5, 0.5), n_hvgs = 1000, ncomp = 10)
so <- Seurat::as.Seurat(sim)
so@reductions[["pca"]] <- Seurat::CreateDimReducObject(
  embeddings = SingleCellExperiment::reducedDim(sim, "PCA"),
  loadings = attr(SingleCellExperiment::reducedDim(sim, "PCA"), "rotation"),
  key = "pca_", assay = SeuratObject::DefaultAssay(so))

so[[SeuratObject::DefaultAssay(so)]] <- as(object = so[[SeuratObject::DefaultAssay(so)]],
                                           Class = "Assay5")
so[[SeuratObject::DefaultAssay(so)]] <- split(x = so[[SeuratObject::DefaultAssay(so)]],
                                              f = so[["Batch"]][, 1])
so <- Seurat::ScaleData(so, verbose = FALSE)
seuv5 <- seuratV5Run(input = so, method = "CCAIntegration",
                     features = rownames(so), verbose = FALSE)

}
