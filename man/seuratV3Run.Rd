% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/seuratV3Run.R
\name{seuratV3Run}
\alias{seuratV3Run}
\title{Seurat V3 method}
\usage{
seuratV3Run(
  input,
  assay = NULL,
  reference = NULL,
  anchor.features = 2000,
  scale = TRUE,
  normalization.method = "LogNormalize",
  sct.clip.range = NULL,
  reduction = "cca",
  l2.norm = TRUE,
  dims = 1:30,
  k.anchor = 5,
  k.filter = 200,
  k.score = 30,
  max.features = 200,
  nn.method = "annoy",
  n.trees = 50,
  eps = 0,
  verbose = TRUE,
  new.assay.name = "integrated",
  features = NULL,
  features.to.integrate = NULL,
  k.weight = 100,
  weight.reduction = NULL,
  sd.weight = 1,
  sample.tree = NULL,
  preserve.order = FALSE
)
}
\arguments{
\item{input}{A list of \linkS4class{Seurat} objects.}

\item{assay}{A vector of assay names specifying which assay to use when
constructing anchors.}

\item{reference}{A vector specifying the object/s to be used as a reference
during integration.}

\item{anchor.features}{Number of features to be used in anchor finding.}

\item{scale}{A logical to scale the features provided.}

\item{normalization.method}{Name of normalization method used:
LogNormalize (default) or SCT.}

\item{sct.clip.range}{Numeric of length two specifying the min and max values
the Pearson residual will be clipped to.}

\item{reduction}{Dimensional reduction to perform when finding anchors.}

\item{l2.norm}{Perform L2 normalization on the CCA cell embeddings
after dimensional reduction.}

\item{dims}{Number of dimensions.}

\item{k.anchor}{Number of neighbors (k) to use when picking anchors.}

\item{k.filter}{Number of neighbors (k) to use when filtering anchors.}

\item{k.score}{Number of neighbors (k) to use when scoring anchors.}

\item{max.features}{The maximum number of features to use when specifying
the neighborhood search space in the anchor filtering.}

\item{nn.method}{Method for nearest neighbor finding.}

\item{n.trees}{More trees gives higher precision when using annoy
approximate nearest neighbor search.}

\item{eps}{Error bound on the neighbor finding algorithm.}

\item{verbose}{Print progress bars and output.}

\item{new.assay.name}{Name for the new assay containing
the integrated data.}

\item{features}{Vector of features to use.}

\item{features.to.integrate}{Vector of features to integrate.}

\item{k.weight}{Number of neighbors to consider when weighting anchors.}

\item{weight.reduction}{Dimension reduction to use when calculating
anchor weights.}

\item{sd.weight}{Controls the bandwidth of the Gaussian kernel for weighting.}

\item{sample.tree}{Specify the order of integration.}

\item{preserve.order}{Do not reorder objects based on size for each
pairwise integration.}
}
\value{
A \linkS4class{Seurat} object that contains the corrected matrix.#'
}
\description{
SeuratV3 is an anchor-based method.
}
\examples{
sim <- simulated_data(nGenes = 1000, batchCells = c(150, 200),
                      group.prob = c(0.5, 0.5), n_hvgs = 1000, ncomp = 10)
so <- as.Seurat(sim)
VariableFeatures(so) <- rownames(so)
so[["pca"]] <- CreateDimReducObject(embeddings = reducedDim(sim, "PCA"),
                                    loadings = attr(reducedDim(sim, "PCA"), "rotation"),
                                    key = "pca_", assay = DefaultAssay(so))
ll <- SplitObject(so, split.by = "Batch")
seuv3 <- seuratV3Run(input = ll, reduction = "cca")

}
